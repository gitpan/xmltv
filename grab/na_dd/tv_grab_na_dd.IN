#!/usr/bin/perl -w

=pod

=head1 NAME

tv_grab_na_dd - Grab TV listings for North America using Zap2IT's Data Direct service.

=head1 SYNOPSIS

    tv_grab_na_dd --help

    tv_grab_na_dd --version
    
    tv_grab_na_dd --configure [--config-file FILE] [--dd-data FILE]
                              [--reprocess] [--auto-config add|ignore]

    tv_grab_na_dd --list-lineups [--config-file FILE] [--dd-data FILE]
                              [--reprocess]

    tv_grab_na_dd [--config-file FILE] [--dd-data FILE]
                  [--reprocess] [--auto-config add|ignore]
                  [--days N]  [--offset N] [--quiet]
                  [--old-chan-id] [--low-mem] [--output FILE]
                  [--list-channel]
                  [--download-only]

=head1 DESCRIPTION

This scripts downloads listings from Zap2IT's DataDirect service,
converts it to XMLTV format, and outputs the results.

You must first register with Data Direct at: L<http://labs.zap2it.com>

You'll need to provide the XMLTV certificate code C<ZYZM-TE5O-SBUT> (Letter O)

The data is provided free of charge, except for a short periodic web survey. 

Once you've registered, run C<tv_grab_na_dd --configure> to provide
your username and password.

Once configured, running B<tv_grab_na_dd> with no arguments will output
listings in XML format to standard output.

=head1 Mode selection (default is grab mode) 

=over

=item --configure

Activates configure mode,  If a config file already exists the values are used as defaults.

=item --list-lineups

Lists available lineups.  Only requires username in the config file. Used by programs that
automate the L<--configure> process.


=back

=head1 General Options

=over

=item --config-file I<file>

Set the name of the configuration file, the default is B<~/.xmltv/tv_grab_na_dd.conf>.
This is the file created during L</--configure> mode.

=item --dd-data I<file>

Store DataDirect data to this file. (default is a temporary file)

=item --reprocess

Don't don't get data from DataDirect, but reprocess a file saved with L</--dd-data>.

=item --auto-config I<add|ignore>

When used in --configure mode, updates the config file, removing old channels, and adding or
ignoring new channels.  Prompts are skipped if defaults are available in the current config file.

When used in grab mode, appends new channels to the config file.

=back

=head1 Grabber Mode options

=over

=item --days I<n>

grab I<n> days.  The default is 7. 

=item --offset I<n>

start N days after the default.

=item --quiet

suppress some messages normally written to standard error.

=item --old-chan-id

use a channel id similar to the one used by the old B<tv_grab_na> grabber.

=item --low-mem

Omit all but the most basic program information. Reduces memory usage.

=item --output I<file>

write xml to I<file> rather than standard output.

=item --list-channel

same as B<--days> 0

=item --download-only

Don't generate any output, just fetch the data.  Personally I don't see the point,
but it was requested and easy to add.

=back

=head1 Zap2It Data Direct account expirations.

As mentioned above, Zap2IT's Data Direct service is not freeware, but I<surveyware>.
Periodically (currently every 3 months) you will be asked to fill out a short survey in
exchange for the data.  It's a win-win for everyone.

A message from Zap2IT is passed on by the grabber informing you of your
account expiration date.  Seven days before expiration, Zap2IT will send you a email
asking you to fill out another survey.

=head1 Automating configuration

Sometimes applications want to call B<tv_grab_na_dd> as a standalone application,
but automate the configure process.  The best way is to hook in to the XMLTV::Ask module,
but if that's not available, here is a solution.

=over

Step1. Application creates config file with username (and optionally password).

Step2. C<tv_grab_na_dd --dd-file lineups.xml --list-lineups> 

Step3. Application adds desired lineup to config file.

Step4. C<tv_grab_na_dd --dd-file lineups.xml --reprocess --auto-config add --list-channels>

Step5. Application edits config file as needed, and deletes lineups.xml.

=back

=head1 Handling Multiple Linups

tv_grab_na_dd only outputs a single lineup. If your DataDirect
account has multiple lineups, they are all downloaded even though only one is output.

To process multiple lineups, specify a different L</--config-file>.
To prevent re-downloading the data on subsequent passes, the L<--reprocess> option is recommended.

Here's an example: (the = sign is optional, but helps readability)

 tv_grab_na_dd --config-file=lineup1.dat --output=lineup1.xml --dd-file=dd.xml
 tv_grab_na_dd --config-file=lineup2.dat --output=lineup2.xml --dd-file=dd.xml --reprocess
 tv_grab_na_dd --config-file=lineup3.dat --output=lineup3.xml --dd-file=dd.xml --reprocess

Each config file specifies the desired lineup and channel list. The login information is
is only used in the first command, but it doesn't hurt in the other entries.

If you want to merge the lineups into a single file, you can use tv_cat

 tv_cat lineup1.xml lineup2.xml lineup3.xml >guide.xml

=head1 Adding icon links to listings

B<tv_grab_na_dd> checks for channel icons in a directory B<I<share>>/B<icons>.  The I<share> directory
is usually set during the install.  For windows exe users, it defaults to the location where
B<xmltv.exe> is.  B<tv_grab_na_icons> is available to download the icons.

=head1 Notes on channel lists

Channel lists can be configured both at the DataDirect website and through the grabber.  This is done to
allow multiple config files with different channel lists.  DataDirect only supports a single channel map
per lineup.

=head1 Notes on episode numbers

Three episode-num formats are supplied (when available)

=over

=item xmltv_ns

always C<..a/b> for part C<a> of C<b>. First two xmltv_ns fields always blank.

=item dd_progid

TMS generated C<a.b.c/d> where C<a> is a unique program id, C<b> is a unique episode id,
C<c/d> is part C<c> of C<d> similar to xmltv_ns.

=item onscreen

Distributor-designated number corresponding to an episode of a specific show. Varies by distributor.

=back

=head1 Notes on passwords

If a password is stored in the config file, the config file should be properly protected.
Instead of storing the password in the config file, it can be omitted, and will be prompted for. 

=head1 Notes on lineup changes

DataDirect currently adds a channel to your lineup automatically when it is available.  When
B<tv_grab_na_dd> sees the new channel in the DataDirect lineup, it prints a message (and
potentially adds or ignores it based on --auto-config).

If you are sensitive to bandwidth issues, I would set B<--auto-config ignore> and periodically check
your B<--config-file> for ignored channels and remove from your DataDirect Lineup L<http://labs.zap2it.com>.

Zap2it is considering making this configurable, but at the moment it is not.

=head1 Known issues

none!

=head1 SEE ALSO

L<xmltv(5)>.

=head1 Author

Author/Maintainer: Robert Eden, rmeden@yahoo.com

=head2 Contributors:

=over

Ed Avis, ed@membled.com

Don Huettl, drh@huettl.net

Matti Airas, mairas@iki.fi (I used tv_grab_fi as a template)

The folks at Tribune Media L<http://labs.zap2it.com/>

and of course everyone else I forgot to mention. :)

=cut

#################################################################
# initializations

use strict;
use Data::Dumper;
use Date::Manip;
use Time::Local;
use SOAP::Lite;
use File::Temp qw(tempfile);
use Getopt::Long;
use XML::Twig 3.10;
use constant Have_bar => eval { require Term::ProgressBar; 1 };

use XMLTV;
use XMLTV::Ask;
use XMLTV::Config_file;
use XMLTV::Version '$Id: tv_grab_na_dd.IN,v 1.10 2004/05/08 09:15:26 epaepa Exp $';
use XMLTV::Usage <<END
$0: get lists from Zap2IT's DataDirect service in XMLTV format

    $0 [--version] [--help]
  
To Configure
    $0 --configure [--config-file FILE] [--dd-data FILE]
                              [--reprocess] [--auto-config add|ignore]
To get listings
    $0 [--config-file FILE] [--dd-data FILE]
                  [--reprocess] [--auto-config add|ignore]
                  [--days N]  [--offset N.N] [--quiet]  [--old-chan-id]
                  [--low-mem] [--output FILE]
                  [--download-only]
END
;

#
# module version checking doesn't work with XMLTV version numbers
#
die "*ERROR* XMLTV.PM 0.5.32 required\n" if $XMLTV::VERSION lt '0.5.32';

#
# Global Vars
# 
my $SHARE_DIR ='c:/share/xmltv';
my @messages;           # DD warnings.
my %chan_config;         # Active/inactive channels.
my %chan_id;            # quick channel id lookup
my %station;            # DD station data
my %lineups;            # DD channel mapping data
my %program;            # DD program data
my %crew;               # DD crew data
my %programGenre;       # DD Genre data

my $bar;                # handle for status bar
my $count;              # record count (for status bar)
my $DEBUG          =0;  # debug mode
my $config_file;        # config file name
my $tz_offset=0;
my $start_time=time();
my $prog_count=0;        # record count;
my %old_lineups=();      # used for DD schema 1.2 -> 1.3 migration
my %icons=();            # holds icons (if present)

my $dd_user="";         # dd username
my $dd_pass="";         # dd password
my $dd_lineup="";       # dd lineup (empty all lineups)
my $dd_data;            # temp file handle to store DD data
my $dd_schema="";       # dd schema found
my $dd_data_name;       # filename for above
my $dd_data_size;       # amount of data returned 
my $dd_start;           # dd start time
my $dd_stop;            # dd stop time

my $opt_help;           # ask for help
my $opt_configure;      # configure mode
my $opt_config_file ;   # config_file_name
my $opt_output;         # output name
my $opt_days       =10; # days to fetch
my $opt_offset     =0;  # day to start
my $opt_quiet      =0;  # supress messages
my $opt_lineup     =''; # limit results to one lineup
my $opt_old_chan_id=0;  # use tv_grab_na style chan ids
my $opt_low_mem    =0;  # use as little memory as you can
my $opt_dd_data    =''; # save dd data
my $opt_reprocess  =''; # reprocess dd data
my $opt_auto_config  =''; # auto add/ignore channels
my $opt_list_channels='';  
my $opt_list_lineups='' ; 
my $opt_down_only=0     ; 
my $opt_beta_data=0     ; # undocumented flag to grab beta DD schema
my $opt_tz_offset=undef;

#
# Process command line
#
foreach (@ARGV) {
    tr/_/-/ if /^--/; # older option style
}
GetOptions(
	       'help'          => \$opt_help,
    	   'configure'     => \$opt_configure,
    	   'config-file=s' => \$opt_config_file,
    	   'config_file=s' => \$opt_config_file,
    	   'output=s'      => \$opt_output,
           'days=i'        => \$opt_days,
    	   'offset=i'      => \$opt_offset,
    	   'quiet'         => \$opt_quiet,
    	   'lineup=s'      => \$opt_lineup,
           'old_chan_id'   => \$opt_old_chan_id,
           'old-chan-id'   => \$opt_old_chan_id,
           'low_mem'       => \$opt_low_mem,
           'low-mem'       => \$opt_low_mem,
           'dd_data=s'     => \$opt_dd_data,
           'dd-data=s'     => \$opt_dd_data,
           'reprocess'     => \$opt_reprocess,
           'auto-config=s' => \$opt_auto_config,
           'auto_config=s' => \$opt_auto_config,
           'list-channels' => \$opt_list_channels,
           'list-lineups'  => \$opt_list_lineups,
           'download-only' => \$opt_down_only,
           'beta-data'     => \$opt_beta_data,
           'debug'         => \$DEBUG,
    	   'share=s'       => \$SHARE_DIR,

	  )
  or usage(0);
usage(1) if $opt_help;
die "number of days must not be negative\n"         if ($opt_days < 0);
die "must specify --dd_data during reprocess\n"     if $opt_reprocess and not $opt_dd_data;
die "--auto-config must be 'add' or 'ignore'\n"     if $opt_auto_config && $opt_auto_config !~ /^(add|ignore)$/;
die "--down-only without --dd-data is pointless!\n" if $opt_down_only && ! $opt_dd_data;

$opt_days    = 0 if $opt_configure || $opt_list_channels || $opt_list_lineups;
$config_file = XMLTV::Config_file::filename($opt_config_file, 'tv_grab_na_dd', $opt_quiet);


########################################################################
#
# Load config file
#
if (-e $config_file && ( !$opt_configure || -s $config_file ))
{
    foreach (XMLTV::Config_file::read_lines($config_file))
    {
        next unless defined $_;
        chomp;
        my( $setting, $val ) = split( /:\s+/o, $_, 2 );

        if ( $setting =~ /^(not )?channel$/o )
        {
            $chan_config{$val} = $1 ? 0 : 1;
        }
        elsif ( $setting eq 'username' )
        {
            $dd_user = $val;
        }
        elsif ( $setting eq 'password' )
        {
            $dd_pass = $val;
            print STDERR "\n**WARNING** Password in config file, protect as required\n\n";
        }
        elsif ( $setting eq 'timezone' )
        {
            $opt_tz_offset  = $val;
        }
        elsif ( $setting eq 'lineup' )
        {
            $dd_lineup = $val;
#
# special processing for dd_schema 1.2 -> 1.3
#
            if (exists $old_lineups{$dd_lineup})
            {
                print STDERR "Lineup IDs have changed. Please run --configure\n";
                $dd_lineup = $old_lineups{$dd_lineup};
            }
        }
        else
        {
            warn "Unknown setting: $setting, skipping.\n";
        }
    }
} # load config file

#
#
# start --configure mode
#

if ( $opt_configure )
{
    open(CONF,">$config_file") or die "can't open config file: $config_file\n";
    if ( ! $opt_auto_config )
    {
       say("
DD data is in UTC by default
Please specify the appropriate offset
(We're working on improving this)
+0000 UTC
-0400 Eastern  Daylight
-0500 Eastern  Standard or Central Daylight
-0600 Central  Standard or Mountain Daylight
-0700 Mountain Standard or Pacific Daylight
-0800 Pacific  Standard
");
       while (1)
       {
#        $opt_tz_offset='local' unless length($opt_tz_offset);
#        $opt_tz_offset=ask("Timezone offset (+/-####), or 'local' ($opt_tz_offset)")||'local';
         if (defined $ENV{TZ})
         {
             $opt_tz_offset=$ENV{TZ} unless defined $opt_tz_offset || $ENV{TZ} !~ /[+-]\d\d\d\d/;
         }
         $opt_tz_offset='+0000'  unless defined $opt_tz_offset;
         $opt_tz_offset=ask("Timezone offset (+/-####) ($opt_tz_offset)") || $opt_tz_offset;
         last if $opt_tz_offset =~ /[+-]\d\d\d\d/;
       }

        say("
Free Data Direct registration required in advance.
You can get an ID at http://labs.zap2it.com
Specify certificate code: 'ZYZM-TE5O-SBUT' (Letter O)

    ");
        $dd_user=ask("Username ($dd_user):")|| $dd_user || die "DataDirect Username Required\n";
        $dd_pass=ask("
WARNING: Storing the password in the config file is not secure
If password is blank, it will be prompted as needed(more secure)
Unsecured password ('x':delete,default:<keep>,):")|| $dd_pass;
    }
    $dd_pass='' if $dd_pass eq 'x';
    print CONF "username: $dd_user\n";
    print CONF "password: $dd_pass\n" if $dd_pass;
    print CONF "timezone: $opt_tz_offset\n";

}

die "*ERROR* Username not specified. Please run --configure\n" unless $dd_user;
die "*ERROR* Lineup not specified.  Please run --configure\n"  unless $dd_lineup || $opt_list_lineups || $opt_configure;
die "*ERROR* Local timezone not yet supported. Please run --configure\n" unless defined $opt_tz_offset;
die "*ERROR* Bad timezone offset Please run --configure\n" unless $opt_tz_offset =~ /[+-]\d\d\d\d/;

$tz_offset = substr($opt_tz_offset,0,3)*3600+substr($opt_tz_offset,3,2)*60;
$opt_tz_offset='UTC' unless $tz_offset;
print STDERR "Using TZ=<$opt_tz_offset> offset=<$tz_offset>\n" if $DEBUG;

#
# compute start/stop time
#
{
    Date_Init("TZ=$opt_tz_offset");
    my $start = DateCalc("Midnight","+ $opt_offset days") || die "Can't compute <$opt_offset> days\n";
    my $stop  = DateCalc($start    ,"+ $opt_days   days") || die "Can't compute <$opt_days> days\n";

#
# if days==0, back start time up by a minute to try and get only channels
#
    $start = DateCalc($start,"- 1 minute") if $opt_days==0;

    die "*ERROR* start($start) before stop($stop)\n" unless $stop gt $start;
    
    $dd_start=UnixDate(Date_ConvTZ($start,"","UTC"),"%Y-%m-%dT%H:%M:%SZ");
    $dd_stop =UnixDate(Date_ConvTZ($stop ,"","UTC"),"%Y-%m-%dT%H:%M:%SZ");

    print STDERR "dd_start: $start,$dd_start\n" if $DEBUG;
    print STDERR "dd_stop : $stop,$dd_stop\n" if $DEBUG;
} # compute date

#
# open dd data file (temp, or created)
#
if ($opt_reprocess)
{
    die "$opt_dd_data file not found\n" unless -e $opt_dd_data;
    $dd_data_name = $opt_dd_data;
    $dd_data      = new IO::File("<$dd_data_name");
    $dd_data_size= -s $dd_data;
}
else
{
#
# get DD data
#
    #
    # open file to store DD XML
    #
    if ($opt_dd_data)
    {
        $dd_data_name = $opt_dd_data;
        $dd_data      = new IO::File("+>$dd_data_name");
    }
    else
    {
        ($dd_data,$dd_data_name) = tempfile('tv_grab_na_dd_XXXX',
                                             DIR    => File::Spec->tmpdir(),
                                             SUFFIX => '.tmp',
                                             UNLINK=>($DEBUG ? 0 : 1));
    }

#
# Prompt for password (if needed)
#
    $dd_pass=~s/^\s//g;
    unless (length($dd_pass))
    {
        require Term::ReadKey;
        $| = 1;
        print STDERR "Password for $dd_user: ";
        Term::ReadKey::ReadMode('noecho');
        chomp($dd_pass = <STDIN>);
        Term::ReadKey::ReadMode('restore');
        print STDERR "\n";
    }

#
# Fetch data
# 
    print STDERR "Fetching from DataDirect\n";
    print STDERR "    dd_data is in $dd_data_name\n" if $DEBUG || $opt_dd_data;   

    sub SOAP::Transport::HTTP::Client::get_basic_credentials
    {
       return "$dd_user" => "$dd_pass";
    }

    my $dd_service='http://docs.tms.tribune.com/tech/tmsdatadirect/zap2it/xtvd.wsdl';
    $dd_service='http://docs.tms.tribune.com/tech/tmsdatadirect/zap2it/beta/xtvd.wsdl' if $opt_beta_data;

    my $proxy='http://localhost/';
    if (exists $ENV{HTTP_PROXY})
    {
        $proxy=$ENV{HTTP_PROXY};
    }

    my $time=time();
    my $soap= SOAP::Lite
            -> service($dd_service)
            -> outputxml('true')
#           -> on_debug(1)
            -> on_fault( sub {
                             	my($soap,$res)=@_;
                              	die "SOAP call failed: "
                             	    .(ref $res ? $res->faultstring
                              	               : $soap->transport->status)
                              	    ."\n";
                             })
            -> proxy($proxy, options => {compress_threshold => 10000,
                                         timeout            => 420});
    $dd_data->print($soap->download("<startTime>$dd_start</startTime><endTime>$dd_stop</endTime>"));
    $dd_data->flush;
    $dd_data_size= -s $dd_data;
    die 'got empty result from SOAP call' if $dd_data_size == 0;
    $time = int(time() - $time);
    printf STDERR "    Fetched %d k/bytes in %d seconds\n",$dd_data_size/1024,$time;
} # get data

#
# quit if --download-only
#
exit(0) if $opt_down_only;

#
# load supporting details
#
my $twig=XML::Twig->new(   
         twig_roots    => { HTML => 1, message => 1, xtvd => 1 },
         ignore_elts   => { schedules => 1 },
		 twig_handlers => 
		      {
		         HTML     => sub {
                                  die "\n*** FETCH ERROR***\n".$_->first_child_text;
                		         },
                 xtvd  => sub {
                                  $dd_schema=$_->att('schemaVersion');
				  die "did not see schemaVersion attribute in <xtvd>"
				    if not defined $dd_schema;
                                  $_->twig->purge;
                                  return 0;
                                 },
                 message  => sub {
                                  push @messages, $_->first_child_text;
                                  $_->twig->purge;
                                  return 0;
                                 },

		         stations => sub { $_->twig->purge;  return 0;},
		         station  => sub {
                                  my $hash=$_->simplify;
                                  $station{$_->att('id')}=$hash;
                                  $_->twig->purge;
                                  return 0;
                		         },
		         lineups => sub { $_->twig->purge;  return 0;},
                 lineup  => sub {
                                  my $hash = $_->simplify;
                                  my $name = $_->att('name');
                                  my $id   = $_->att('id');
                                  $hash->{orig_id}=$name;
                                  $hash->{name}   =$name;
                                  if (exists $lineups{$name})
                                  {
                                    $name.='-2'; # deal with dupe names
                                  }
#
# note. special processing for dd_schema 1.2 -> 1.3 conversion
#
                                  if ($id)
                                  {
                                    $old_lineups{$name}=$id;
                                    $lineups{$id}=$hash;
                                  }
                                  else
                                  {
                                    $lineups{$name}=$hash;
                                  }
                                  
                                  $_->twig->purge;
                                  return 0;
                                 },
		         programs=> sub { $_->twig->purge;  return 0;},
		         program => sub {
                                  my $hash=$_->simplify;

                                  if ($opt_low_mem)  # only store title/subtitle
                                  {
                                    $program{$_->att('id')}{title}=$hash->{title};
                                    $program{$_->att('id')}{'subtitle'}=$hash->{subtitle} if exists $hash->{subtitle};
                                    $program{$_->att('id')}{'originalAirDate'}=$hash->{originalAirDate} if exists $hash->{originalAirDate};
                                  }
                                  else
                                  {
                                    $program{$_->att('id')}=$hash;
                                  }
                                  $_->twig->purge;  
                                  return 0;
                		         },  
                 productionCrew => sub { $_->twig->purge;  return 0;},
		         crew    => sub {
                                  unless ($opt_low_mem)
                                  {
                                    my $hash=$_->simplify;
                                    $crew{$_->att('program')}=$hash;
                                  }
                                  $_->twig->purge;  
                                  return 0;
                  		          },
                 genres       => sub { $_->twig->purge;  return 0;},
		         programGenre => sub {
                                  unless ($opt_low_mem)
                                  {
                                    my $hash=$_->simplify;
                                    $programGenre{$_->att('program')}=$hash;
                                  }
                                  $_->twig->purge;  
                                  return 0;
                  		          },
		         _all_ => sub {  # for some reason this is not being processed last, can't do the purge
                                  unless ( $opt_quiet || $count++ % 1000 )
                                  {
                                     if ($bar) { $bar->update(tell($dd_data)) }
                                     else      { print STDERR "."            };
                                  }
                                  return 0;
                  		          },
	         });


unless ($opt_quiet)
{
    if (Have_bar) { $bar = new Term::ProgressBar('loading data',$dd_data_size+1) }
    else          { print STDERR "loading data "; }
}
seek($dd_data,0,0);  #rewind
eval { $twig->parse( $dd_data ) };
if ($@) {
    warn "\nerror parsing DD xml: $@\nPartial XML follows:\n";
    my $first_line = 1;
    if ($@ =~ /at line (\d+)/) { $first_line = $1 }
    seek($dd_data, 0, 0);
    while (<$dd_data>)
    {
	next unless $. >= $first_line;
	print STDERR $_;
    }
    die "\nBad XML from DD, cannot continue\n";
}

$bar->update($dd_data_size+1) if $bar;
print STDERR "\n" unless ($opt_quiet || $bar );

$twig=undef;  # destroy twig (just in case)


die "did not see <xtvd> element in downloaded content" if not defined $dd_schema;
warn "DD Schema # is $dd_schema, check for upgrade\n" if $dd_schema > 1.3;

#
# --list-lineup mode
#
if ($opt_list_lineups)
{
    my $id_len=2;
    my $type_len=4;
    my $orig_len=6;
    my $dev_len=6;
    for my $id (sort keys %lineups)
    {
        my $len=length($id);
        $id_len=$len if $len>$id_len;

        $len=length($lineups{$id}{type}||'');
        $type_len=$len if $len>$type_len;

        $len=length($lineups{$id}{orig_id}||'');
        $orig_len=$len if $len>$orig_len;

        $len=length($lineups{$id}{device}||'');
        $dev_len=$len if $len>$dev_len;

    }


    printf STDOUT "%-${id_len}s|%-6s|%-${type_len}s|%-${orig_len}s|%-${dev_len}s|%s\n",
                                                    "Lineup ID",
                                                    "Postal",
                                                    "Type",
                                                    "OrigID",
                                                    "Device",
                                                    "Location";
    for my $id (sort keys %lineups)
    {
          printf STDOUT "%-${id_len}s|%-6s|%-${type_len}s|%-${orig_len}s|%-${dev_len}s|%s\n",$id,
                                                  ,$lineups{$id}{postalCode}||'',
                                                  ,$lineups{$id}{type}||'',
                                                  ,$lineups{$id}{orig_id}||'',
                                                  ,$lineups{$id}{device}||'',
                                                  ,$lineups{$id}{location}||'',
    }
    exit 0;    
}

#
# --configure stage2, process channel list
#
if ($opt_configure)
{
    my %chan_found=();
    my $key;
    $dd_lineup=$old_lineups{$dd_lineup} if exists $old_lineups{$dd_lineup};
    $dd_lineup=(sort keys %lineups)[0]  unless exists $lineups{$dd_lineup};
    if (! $opt_auto_config)
    {
        my @choices=map sprintf("%s|%s,%s",$_,
                                           $lineups{$_}{name},
                                           $lineups{$_}{type}),
                        sort keys %lineups;
        my $val=sprintf("%s|%s,%s",$dd_lineup,
                                   $lineups{$dd_lineup}{name},
                                   $lineups{$dd_lineup}{type});
                                           
        $val = askQuestion("\nWhich Lineup? ($dd_lineup)",$val,@choices);
        $dd_lineup = (split(/\|/,$val))[0];
    }
    print CONF "lineup: $dd_lineup\n";

        $opt_auto_config='add' if !$opt_auto_config && !askBooleanQuestion("
The preferred method for controlling the channel lineup is through
the DataDirect web site, but you can omit channels here as well.
Do you want to skip some channels?",0);

    print "\n";
    
    foreach (@{$lineups{$dd_lineup}{map}})
    {
       my $res='yes';
       my $key=sprintf("%d %s",$_->{channel},$station{$_->{station}}{callSign});
       $chan_found{$key}=1;
       if ($opt_auto_config)
       {
            if (exists $chan_config{$key})
            {
            }
            elsif ($opt_auto_config eq 'add')
            {
                print STDERR "Adding new channel: $key\n";
                $chan_config{$key}=1;
            }
            else
            {
                print STDERR "Ignoring new channel: (see docs about bandwidth issues) $key\n";
                $chan_config{$key}=0;
            }
       }
       else
       {
            $res='no' if exists $chan_config{$key} and ! $chan_config{$key};
            $res = askQuestion("Add channel $key?",$res,qw(yes no all none ));
            $chan_config{$key}=1       if $res=~/^[ya]/i;
            $chan_config{$key}=0       if $res=~/^[n]/i;
            $opt_auto_config='add'     if $res=~/^all/i;
            $opt_auto_config='ign'     if $res=~/^none/i;
       } # ask question (or --auto-new )

       print CONF ( $chan_config{$key} ? '' : 'not ' ), "channel: $key\n";
    } # channel loop

    foreach (sort keys %chan_config)
    {
        next if $chan_found{$_};
        print STDERR "Channel '$_' no longer exists\n";
    }
    close CONF;
    exit 0;
} # --configure channel list

#
# Make sure we have a valid lineup
#
if ( exists $old_lineups{$dd_lineup} )
{
    print STDERR "**Warning** lineup ID has changed, please re-run configure\n";
    $dd_lineup=$old_lineups{$dd_lineup};
}

die "Lineup ($dd_lineup} not found in data\n" unless exists $lineups{$dd_lineup};


#
# Look for icons
#
if (-d "$SHARE_DIR/icons")
{
   foreach (<$SHARE_DIR/icons/*>)
   {
        if (m!^.+/(.+?)\.!)
        {
            my $callsign=$1;
            my $uri=$_;

            next if /url$/i && exists $icons{$callsign};
            
            if (/url$/i)
            {
                open(FILE,$uri) || die "Error opening icon file $uri\n";
                    $uri=<FILE>;
                    close FILE;
                chomp($uri);                
            }
            else
            {
#                $uri=~s!/!\\!g if $^O=~/win/i;
                $uri="file://".$uri;
            }
            $icons{$callsign}=[ {src => $uri } ],
        }
   }
}

#
# open output file
# 
my %w_args;
my $writer;
if (defined $opt_output) {
                            my $fh = new IO::File(">$opt_output");
                            die "cannot write to $opt_output: $!" if not defined $fh;
                            $w_args{OUTPUT} = $fh;
                         }
$w_args{encoding} = 'ISO-8859-1';

$writer = new XMLTV::Writer(%w_args);
$writer->start( {
              'source-info-name'     => 'TMS Data Direct Service',
              'source-info-url'      => 'http://labs.zap2it.com/',
              'generator-info-name'  => 'XMLTV',
      	      'generator-info-url'   => 'http://www.xmltv.org/',
            });


#
# write stations, removing those we don't care about
#
my %seen_station;
for my $map (@{$lineups{$dd_lineup}{map}})
{
    my $sid = $map->{station};
    if ($seen_station{$sid}++)
    {
	warn "station id $sid seen twice in zap2it output, skipping later occurrences\n";
	next;
    }
    my $myid = sprintf("I%d.labs.zap2it.com",$sid);

    my $station=$station{$sid};
    my $key=sprintf("%d %s",$map->{channel},$station->{callSign});

#
# detect new channel (appending to config file is lame, but it works)
#
    unless (exists $chan_config{$key})
    {
       $chan_config{$key}=0; # default ignore
       if ($opt_auto_config)
       {
          $chan_config{$key}=1 if $opt_auto_config eq 'add'; 
          print STDERR ( $opt_auto_config eq 'add' ? "Adding" : "Ignoring" )," new channel: $key\n";

          open(CONF,">>$config_file") or die "can't open config file for update: $config_file\n";
          print CONF ( $chan_config{$key} ? '' : 'not ' ), "channel: $key\n";
          close CONF;
       }
       else
       {
           print STDERR "New channel, rerun --configure and/or change your DataDirect config: $key\n";
       }
    } # new channel

    next unless $chan_config{$key}; #skip?

#
# generate tv_grab_na channel number
#
    if ($opt_old_chan_id)
    {
       $myid = sprintf("C%d%s.zap2it.com",$map->{channel},lc($station->{callSign}));
    }

#
# Set display names:
#           channel + callSign
#           channel + callSign + lineup
#           channel (only)
    my @names;
    push @names, [ sprintf("%s %s"   ,$map->{channel},$station->{callSign})];
    push @names, [ sprintf("%s %s %s",$map->{channel},$station->{callSign},$dd_lineup)];
    push @names, [ $map->{channel} ];

# 
# Now add display names for the fcc
#
    push @names,[sprintf("%d %s %s",$station->{fccChannelNumber},
                                    $station->{callSign},
                                    'fcc')] if exists $station->{fccChannelNumber};

#
# round up the rest we have
#
    for my $key (qw(callSign name affiliate))
    {
            push @names,[ $station->{$key} ] if exists $station->{$key};
    }
    
    unless (@names)
    {
        warn "No display names defined for channel $myid\n";
        next;
    }

    $writer->write_channel({ 'id'           => $myid,
                             'display-name' => \@names,
                             'icon'         => $icons{$station->{callSign}},
                             });

    $chan_id{$sid}=$myid;
} # output  channels

#
# list channels only
#
if ($opt_list_channels)
{
   $writer->end();
   exit 0;
}

#
# prepare to output schedule
#
$twig=XML::Twig->new( twig_roots => { schedule => 1 },
                      twig_handlers => {                 
    schedule => sub {
                     $prog_count++;
                     unless ( $opt_quiet || $count++ % 10 )
                     {
                       if ($bar) { $bar->update(tell($dd_data)) }
                      else      { print STDERR "."            };
                     }

                     my %prog=();
                     my $ptr;
                     my $twig=$_;
                     $_=$twig->simplify;

# Skip programs not in our lineup.
		     if (exists $chan_id{$_->{station}}) {
                  
		
#
# start with elements from schedule tag
#

#
# we generated a TZ offset a while back... this is twice as fast as Date::Manip!
#
                    my $start = timegm(
                                        int( substr($_->{time},17,2) ),
                                        int( substr($_->{time},14,2) ),
                                        int( substr($_->{time},11,2) ),
                                        int( substr($_->{time},8,2) ),
                                        int( substr($_->{time},5,2) - 1 ),
                                        int( substr($_->{time},0,4) - 1900 ) );
                     my @gStart = gmtime( $start+$tz_offset );
                     $prog{start} = sprintf("%d%02d%02d%02d%02d%02d %s",
		                             $gStart[5] + 1900,
					     $gStart[4] + 1,
					     @gStart[3,2,1,0],
					     $opt_tz_offset);

                     my $h = substr($_->{duration},2,2);
                     my $m = substr($_->{duration},5,2);
                     my $stop = $start + ( ( $h * 60 ) + $m ) * 60;
                     my @gStop = gmtime( $stop+$tz_offset );
                     $prog{stop} = sprintf("%d%02d%02d%02d%02d%02d %s",
		                            $gStop[5] + 1900,
            					    $gStop[4] + 1,
			            		    @gStop[3,2,1,0],
					                $opt_tz_offset);

                     $prog{channel} = $chan_id{$_->{station}};
                     $prog{'previously-shown'}={}           if exists $_->{repeat};
                     $prog{audio}{stereo}='stereo'          if exists $_->{stereo};
                     $prog{subtitles}=[{type=>'onscreen' }] if exists $_->{subtitled};

                     if (exists $_->{tvRating})
                     {
                        $_->{tvRating} =~ s/^TV/TV-/  unless $_->{tvRating} =~ /-/;
                        push @{ $prog{rating} }, [$_->{tvRating},'VCHIP'];
                     }

#
# Note, provide multi-part info in xmltv_ns format for those apps that need it 
#
                     if (exists $_->{part}{number} && exists $_->{part}{total})
                     {
                         push @{$prog{'episode-num'}}, [sprintf("..%d/%d",
                                                           $_->{part}{number}-1,
                                                           $_->{part}{total}),
                                                        'xmltv_ns'];
                     }
                                                       
#
# Store TMS Show ID, Episode ID, part in <episode-num> of "id.episode.part/total"
# using our own numbering system.
#
                     if ( $_->{program} =~ /^(..\d{6})(\d{4})/ )
                     {
                       my $value =sprintf("%s.%s",$1,$2);
                          $value.=sprintf(".%d/%d",$_->{part}{number}-1,
                                                   $_->{part}{total}) if exists $_->{part}{number} && exists $_->{part}{total};
                       push @{$prog{'episode-num'}}, [$value,'dd_progid'];
                     }


#
# add elements from program Genre tag
# Note: before program so Genra comes before ShowType in <category>
#
                     if ($ptr = $programGenre{$_->{program}})
                     {
                         if (ref $ptr->{genre} eq 'HASH')
                        {
                            push @{$prog{category}},[$ptr->{genre}{class},'en']
                        }
                        else
                        {
                            foreach (@{$ptr->{genre}})
                            {
                                push @{$prog{category}},[$_->{class},'en'];
                            }
                        }
                     } # Genra items

#
# add elements from program tag
#
#
                     if ($ptr = $program{$_->{program}})
                     {
                        $prog{title}        =[[$ptr->{title},      'en']] if exists $ptr->{title};
                        $prog{'sub-title'}  =[[$ptr->{subtitle}   ,'en']] if exists $ptr->{subtitle};
                        $prog{desc}         =[[$ptr->{description},'en']] if exists $ptr->{description};
                        $prog{date}         =$ptr->{originalAirDate}      if exists $ptr->{originalAirDate}
                                                                             && $_->{program} =~ /^EP/;
                        $prog{date}         =$ptr->{year}                 if exists $ptr->{year};

                        $prog{length}       = substr($ptr->{runTime},2,2)*3600+
                                              substr($ptr->{runTime},5,2)*60 if exists $ptr->{runTime};

                        if (exists $ptr->{advisories})
                        {
                           if (ref $ptr->{advisories}{advisory})
                           {
                              for my $val (@{$ptr->{advisories}{advisory}})
                              {
                                push @{$prog{rating}},[$val,'advisory'];
                              }
                           }
                           else
                           {
                              push @{$prog{rating}},[$ptr->{advisories}{advisory},'advisory'];
                           }
                        }
                        
                        push @{ $prog{rating}  }, [$ptr->{mpaaRating},'MPAA'] if exists $ptr->{mpaaRating};
                       
                        if (exists $ptr->{colorCode})
                        {
                            $prog{video}{colour}=$ptr->{colorCode}; # wants boolean but try anyway
                            $prog{video}{colour}=0 if $ptr->{colorCode} =~ /^B/i;
                        }

                        if (exists $ptr->{starRating})
                        {
                             my $star=length($ptr->{starRating});
                             if ($ptr->{starRating} =~ /\+$/)
                             {
                                  $star -= .5;
                                  $prog{'star-rating'}=[sprintf("%1.1f/%d",$star,4)];
                             }
                             else
                             {                              
                                  $prog{'star-rating'}=[sprintf("%d/%d",$star,4)];
                             }
                        }

                        push @{$prog{category}}, [$ptr->{showType}   ,'en' ] if exists $ptr->{showType};
                        push @{$prog{'episode-num'}}, [$ptr->{syndicatedEpisodeNumber},'onscreen']  if exists $ptr->{syndicatedEpisodeNumber};

                     } # %program items


#
# add elements from crew tag
#
                     if ($ptr = $crew{$_->{program}})
                     {
                        my ( @director, @actor, @writer, @adapter, @producer,
                             @presenter, @commentator, @guest );
                        $ptr->{member}=[$ptr->{member}] if (ref $ptr->{member} eq 'HASH');
                        foreach (@{$ptr->{member}})
                        {
                            my $name="";
                            $name.=$_->{givenname}." " unless ref $_->{givenname};
                            $name.=$_->{surname}       unless ref $_->{surname};
                            push @actor     ,$name if $_->{role} eq 'Actor';
                            push @guest     ,$name if $_->{role} eq 'Guest Star';
                            push @presenter ,$name if $_->{role} eq 'Host';
                            push @director  ,$name if $_->{role} eq 'Director';
                            push @producer  ,$name if $_->{role} eq 'Executive Producter';
                            push @producer  ,$name if $_->{role} eq 'Producter';
                            push @writer    ,$name if $_->{role} eq 'Writer';
                        }

                        $prog{credits}{actor    }=\@actor     if @actor   ;
                        $prog{credits}{director }=\@director  if @director;
                        $prog{credits}{guest    }=\@guest     if @guest;
                        $prog{credits}{presenter}=\@presenter if @presenter;
                        $prog{credits}{producer }=\@producer  if @producer;
                        $prog{credits}{writer   }=\@writer    if @writer;
                     } #crew items

#
# write record
#
                     $writer->write_programme(\%prog);
                     $twig->twig->purge;
                     return 0;
       		     }
       		 }, # schedule subroutine
	         }); #twig setup

#
# rescan data, looking for schedule items
#
unless ($opt_list_channels)
{
    seek($dd_data,0,0);  #rewind
    unless ($opt_quiet)
    {
        if (Have_bar) { $bar = new Term::ProgressBar('Writing schedule',$dd_data_size+1) }
        else          { print STDERR "Writing schedule"; }
    }
    my $time=time();
    $twig->parse( $dd_data );
    print STDERR "\n" unless ($opt_quiet || $bar );
    $bar->update($dd_data_size+1) if $bar;

    $writer->end();
    if (@messages)
    {
        print STDERR "Message: $_\n" foreach @messages;
    }

    printf STDERR "Downloaded %d programs in %d seconds\n",$prog_count,time()-$start_time
        unless $opt_quiet;
}

exit(0);

